If you want to use getOptionalString for fetching configuration values (to handle cases where certain values might be missing), you can modify the implementation accordingly. Here’s the updated approach:

Step 1: Update the config.d.ts

Modify the readOpenFgaConfig function to use getOptionalString and provide fallback values if needed.

import { Config } from '@backstage/config';

export interface OpenFgaConfig {
  baseUrl: string;
  storeId: string;
  authorizationModelId: string;
}

export function readOpenFgaConfig(config: Config): OpenFgaConfig {
  const openFgaConfig = config.getOptionalConfig('openFga');

  if (!openFgaConfig) {
    throw new Error('Missing openFga configuration in app-config.yaml');
  }

  return {
    baseUrl: openFgaConfig.getOptionalString('baseUrl') || 'https://default.openfga.com',
    storeId: openFgaConfig.getOptionalString('storeId') || 'default-store-id',
    authorizationModelId: openFgaConfig.getOptionalString('authorizationModelId') || 'default-model-id',
  };
}

Step 2: Update client.ts

The rest of the code remains largely unchanged, except for how the configuration is initialized. The readOpenFgaConfig function now safely handles missing configuration values.

import fetch from 'node-fetch';
import { Config } from '@backstage/config';
import { OpenFgaConfig, readOpenFgaConfig } from './config';

interface OpenFgaRequest {
  tuple_key: { user: string; relation: string; object: string };
  authorization_model_id: string;
}

interface OpenFgaResponse {
  allowed: boolean;
  ok?: boolean;
  message: string;
}

let permissionResponse: OpenFgaResponse | null = null;

export function getPermissionResponse(): OpenFgaResponse | null {
  return permissionResponse;
}

let openFgaConfig: OpenFgaConfig;

export function initializeOpenFga(config: Config) {
  openFgaConfig = readOpenFgaConfig(config);
}

export async function sendPermissionRequest(entityName: string, action: string, userName: any): Promise<OpenFgaResponse> {
  const url = `${openFgaConfig.baseUrl}/stores/${openFgaConfig.storeId}/check`;

  const relation = action.toLowerCase() === 'delete' ? 'catalog_entity_delete' : 'catalog_entity_read';

  const requestBody: OpenFgaRequest = {
    tuple_key: {
      user: `${userName}`,
      relation,
      object: `catalog_entity:${entityName}`,
    },
    authorization_model_id: openFgaConfig.authorizationModelId,
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    throw new Error(`OpenFGA API call failed with status: ${response.status}`);
  }

  const data = (await response.json()) as OpenFgaResponse;
  permissionResponse = data;
  return data;
}

export async function addPolicy(entityName: string, accessType: string, userName: any): Promise<OpenFgaResponse> {
  const url = `${openFgaConfig.baseUrl}/stores/${openFgaConfig.storeId}/write`;

  const requestBody = {
    writes: {
      tuple_keys: [
        {
          _description: `Add ${userName} as ${accessType} on catalog_entity:${entityName}`,
          user: `${userName}`,
          relation: accessType,
          object: `catalog_entity:${entityName}`,
        },
      ],
    },
    authorization_model_id: openFgaConfig.authorizationModelId,
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  const data = (await response.json()) as OpenFgaResponse;
  return data;
}

export async function revokePolicy(entityName: string, accessType: string, userName: any): Promise<OpenFgaResponse> {
  const url = `${openFgaConfig.baseUrl}/stores/${openFgaConfig.storeId}/write`;

  const requestBody = {
    deletes: {
      tuple_keys: [
        {
          _description: `Revoke ${userName} as ${accessType} on catalog_entity:${entityName}`,
          user: `${userName}`,
          relation: accessType,
          object: `catalog_entity:${entityName}`,
        },
      ],
    },
    authorization_model_id: openFgaConfig.authorizationModelId,
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  const data = (await response.json()) as OpenFgaResponse;
  return data;
}

Step 3: Default Values in getOptionalString

	•	Default Values: The getOptionalString function allows you to specify fallback values if the configuration key is missing. For example:
	•	baseUrl: Defaults to "https://default.openfga.com" if not provided.
	•	storeId: Defaults to "default-store-id" if not provided.
	•	authorizationModelId: Defaults to "default-model-id" if not provided.

Step 4: Ensure app-config.yaml Alignment

Ensure the openFga configuration is present in your app-config.yaml file to avoid using default values unnecessarily.

openFga:
  baseUrl: "https://example.openfga.com"
  storeId: "your-store-id"
  authorizationModelId: "your-authorization-model-id"

Summary of Changes

	1.	getOptionalString: Ensures your app can handle missing configurations gracefully.
	2.	Fallback Values: Prevents runtime errors due to missing configuration keys.
	3.	Dynamic Initialization: Keeps the initialization process dynamic and adaptable to your environment.

Let me know if you need further customization!