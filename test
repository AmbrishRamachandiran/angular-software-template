client.ts


import { ConfigApi, configApiRef } from '@backstage/core-plugin-api';
import { OpenFgaRequest, OpenFgaResponse } from './client';
import fetch from 'node-fetch';

// Send Permission Request using configuration from app-config.yaml
export async function sendPermissionRequest(
  config: ConfigApi, // Inject the ConfigApi
  entityName: string,
  action: string,
  userName: any
): Promise<OpenFgaResponse> {
  // Access configuration values from app-config.yaml
  const openFgaBaseUrl = config.getString('openFga.baseUrl');
  const openFgaStoreId = config.getString('openFga.storeId');
  const authorizationModelId = config.getString('openFga.authorizationModelId');

  const url = `${openFgaBaseUrl}/stores/${openFgaStoreId}/check`;

  const relation = action.toLowerCase() === 'delete' ? 'catalog_entity_delete' : 'catalog_entity_read';

  const requestBody: OpenFgaRequest = {
    tuple_key: {
      user: `${userName}`,
      relation,
      object: `catalog_entity:${entityName}`,
    },
    authorization_model_id: authorizationModelId,
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    throw new Error(`OpenFGA API call failed with status: ${response.status}`);
  }

  const data = await response.json() as OpenFgaResponse;
  return data;
}



module.ts

import { createBackendModule } from '@backstage/backend-plugin-api';
import { policyExtensionPoint } from '@backstage/plugin-permission-node/alpha';
import { AOpenFgaCatalogPolicy } from './policy';
import { configApiRef, ConfigApi } from '@backstage/core-plugin-api';

// Registering your backend module
export const permissionModuleACatalogPolicy = createBackendModule({
  pluginId: 'permission',
  moduleId: 'a-name-policy',
  register(reg) {
    reg.registerInit({
      deps: { policy: policyExtensionPoint, configApi: configApiRef }, // Injecting ConfigApi
      async init({ policy, configApi }) {
        const openFgaApi = new AOpenFgaCatalogPolicy(configApi); // Passing ConfigApi to your policy handler

        policy.setPolicy(openFgaApi);
      },
    });
  },
});


policy.ts


import { ConfigApi } from '@backstage/core-plugin-api';
import { AuthorizeResult, PolicyDecision, isResourcePermission } from '@backstage/plugin-permission-common';
import { PermissionPolicy, PolicyQuery } from '@backstage/plugin-permission-node';
import { BackstageIdentityResponse } from '@backstage/plugin-auth-node';
import { sendPermissionRequest } from './client';

export class AOpenFgaCatalogPolicy implements PermissionPolicy {
  private readonly config: ConfigApi;

  constructor(config: ConfigApi) {
    this.config = config;
  }

  async handle(request: PolicyQuery, user: BackstageIdentityResponse): Promise<PolicyDecision> {
    if (isResourcePermission(request.permission, 'catalog-entity')) {
      if (request.permission.name === 'catalog.entity.delete') {
        const entityName = 'example-website'; // You can replace this with dynamic entity fetching
        const userName = user.identity.ownershipEntityRefs;

        if (!entityName) {
          return { result: AuthorizeResult.DENY };
        }

        try {
          const response = await sendPermissionRequest(this.config, entityName, 'Delete', userName);

          return response.allowed
            ? { result: AuthorizeResult.ALLOW }
            : { result: AuthorizeResult.DENY };
        } catch (error) {
          console.error('Error checking permission:', error);
          return { result: AuthorizeResult.DENY };
        }
      }

      return { result: AuthorizeResult.ALLOW };
    }

    return { result: AuthorizeResult.DENY };
  }
}
