import React, { useState, useEffect } from 'react';
import { 
  Box, Typography, Select, MenuItem, FormControl, FormLabel, Button 
} from '@material-ui/core';
import { makeStyles } from '@material-ui/core/styles';
import { sendPermissionRequest, addPolicy, revokePolicy } from '../../client';
import Alert from '@material-ui/lab/Alert';
import { useApi, identityApiRef } from '@backstage/core-plugin-api';
import { catalogApiRef } from '@backstage/plugin-catalog-react';

const actionOptions = ['Read', 'Delete'];
const accessTypeOptions = ['owner', 'viewer'];

const useStyles = makeStyles({
  success: {
    color: 'green',
  },
  danger: {
    color: 'red',
  },
  info: {
    color: 'blue',
  },
  button: {
    width: '210px',
    height: '40px',
  },
  box: {
    width: '45%',
    minHeight: '300px',
  },
  alert: {
    minHeight: '50px',
    maxWidth: '40px',
  },
});

export const OpenfgaCatalogComponent = () => {
  const classes = useStyles();
  const [entities, setEntities] = useState<string[]>([]);
  const [user, setUser] = useState<string[]>([]);
  const [selectedEntity, setSelectedEntity] = useState<string>('');
  const [selectedAction, setSelectedAction] = useState<string>(actionOptions[0]);
  const [selectedAccessType, setSelectedAccessType] = useState<string>(accessTypeOptions[0]);
  const [feedbackMessage, setFeedbackMessage] = useState<{ type: string; message: string } | null>(null);
  const catalogApi = useApi(catalogApiRef);
  const identityApi = useApi(identityApiRef);

  const handleEntityChange = (event: any) => setSelectedEntity(event.target.value);
  const handleActionChange = (event: any) => setSelectedAction(event.target.value);
  const handleAccessTypeChange = (event: any) => setSelectedAccessType(event.target.value);

  const fetchEntities = async () => {
    try {
      const { items } = await catalogApi.getEntities({
        fields: ['metadata.name'],
        filter: { kind: 'component' },
      });
      const entityNames = items.map((entity) => entity.metadata.name);
      const { ownershipEntityRefs } = await identityApi.getBackstageIdentity();

      setUser(ownershipEntityRefs);
      setEntities(entityNames);

      if (entityNames.length > 0) {
        setSelectedEntity(entityNames[0]);
      }
    } catch (error) {
      console.error('Error fetching catalog entities:', error);
      setFeedbackMessage({ type: 'error', message: 'Failed to fetch entities. Please try again.' });
    }
  };

  useEffect(() => {
    fetchEntities();
  }, []);

  const handleFeedback = (type: string, message: string) => {
    setFeedbackMessage({ type, message });
    setTimeout(() => setFeedbackMessage(null), 7000);
  };

  const handleActivatePolicy = async () => {
    try {
      const response = await sendPermissionRequest(selectedEntity, selectedAction, user);
      if (response.allowed) {
        handleFeedback('success', `${user} has permission to ${selectedAction} the ${selectedEntity}.`);
      } else {
        handleFeedback(
          'error',
          selectedAction === 'Read'
            ? `${user} only has permission to read the ${selectedEntity}.`
            : `${user} does not have permission to ${selectedAction} the ${selectedEntity}.`
        );
      }
    } catch (error) {
      console.error('Error checking policy:', error);
      handleFeedback('error', 'Failed to check policy. Please try again.');
    }
  };

  const handleAddPolicy = async () => {
    try {
      const response = await addPolicy(selectedEntity, selectedAccessType, user);
      if (Object.keys(response).length === 0 && response.constructor === Object) {
        handleFeedback(
          'success',
          selectedAccessType === 'owner'
            ? `Permission granted for ${user} to read and delete the entity.`
            : `Permission granted for ${user} to read the entity but not delete.`
        );
      } else {
        handleFeedback('error', response.message || 'Failed to add policy.');
      }
    } catch (error) {
      console.error('Error adding policy:', error);
      handleFeedback('error', 'Failed to add policy. Please try again.');
    }
  };

  const handleRevokePolicy = async () => {
    try {
      const response = await revokePolicy(selectedEntity, selectedAccessType, user);
      if (Object.keys(response).length === 0 && response.constructor === Object) {
        handleFeedback(
          'success',
          selectedAccessType === 'owner'
            ? `Permission revoked for ${user} to read and delete the entity.`
            : `Permission revoked for ${user} to read the entity.`
        );
      } else {
        handleFeedback('error', response.message || 'Failed to revoke policy.');
      }
    } catch (error) {
      console.error('Error revoking policy:', error);
      handleFeedback('error', 'Failed to revoke policy. Please try again.');
    }
  };

  return (
    <Box sx={{ border: 1, borderRadius: 0, p: 2, display: 'flex', flexDirection: 'row', justifyContent: 'space-between' }}>
      {/* Check Policy Section */}
      <Box className={classes.box}>
        <Typography className={classes.info} variant="body2" gutterBottom>
          User: {user.join(', ')}
        </Typography>
        <Typography variant="h6" gutterBottom>
          Start Existing Policy
        </Typography>
        <FormControl>
          <FormLabel>Select Entity</FormLabel>
          <Select value={selectedEntity} onChange={handleEntityChange}>
            {entities.map((entityName) => (
              <MenuItem key={entityName} value={entityName}>
                {entityName}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
        <br />
        <FormControl>
          <FormLabel>Select Action</FormLabel>
          <Select value={selectedAction} onChange={handleActionChange}>
            {actionOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
        <Button className={`${classes.success} ${classes.button}`} onClick={handleActivatePolicy}>
          Check Policy
        </Button>
      </Box>

      {/* Modify Policy Section */}
      <Box className={classes.box}>
        <Typography variant="h6" gutterBottom>
          Modify/Add Policy
        </Typography>
        <FormControl>
          <FormLabel>Select Access Type</FormLabel>
          <Select value={selectedAccessType} onChange={handleAccessTypeChange}>
            {accessTypeOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
        <Button className={`${classes.success} ${classes.button}`} onClick={handleAddPolicy}>
          Add Policy
        </Button>
        <Button className={`${classes.danger} ${classes.button}`} onClick={handleRevokePolicy}>
          Revoke Policy
        </Button>
      </Box>

      {/* Feedback Alert */}
      {feedbackMessage && (
        <Alert severity={feedbackMessage.type} className={classes.alert}>
          {feedbackMessage.message}
        </Alert>
      )}
    </Box>
  );
};