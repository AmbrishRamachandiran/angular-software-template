import fetch from 'node-fetch';

interface OpenFgaRequest {
  tuple_key: { user: string; relation: string; object: string };
  authorization_model_id: string;
}

interface OpenFgaResponse {
  allowed: boolean;
  ok?: boolean;
  message: string;
}

let permissionResponse: OpenFgaResponse | null = null;

export function getPermissionResponse(): OpenFgaResponse | null {
  return permissionResponse;
}

// Pass configuration as constructor parameters
export class OpenFgaClient {
  private baseUrl: string;
  private storeId: string;
  private authorizationModelId: string;

  constructor(baseUrl: string, storeId: string, authorizationModelId: string) {
    this.baseUrl = baseUrl;
    this.storeId = storeId;
    this.authorizationModelId = authorizationModelId;
  }

  async sendPermissionRequest(entityName: string, action: string, userName: any): Promise<OpenFgaResponse> {
    const url = `${this.baseUrl}/stores/${this.storeId}/check`;

    const relation = action.toLowerCase() === 'delete' ? 'catalog_entity_delete' : 'catalog_entity_read';

    const requestBody: OpenFgaRequest = {
      tuple_key: {
        user: `${userName}`,
        relation,
        object: `catalog_entity:${entityName}`,
      },
      authorization_model_id: this.authorizationModelId,
    };

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      throw new Error(`OpenFGA API call failed with status: ${response.status}`);
    }

    const data = await response.json() as OpenFgaResponse;
    permissionResponse = data;
    return data;
  }

  async addPolicy(entityName: string, accessType: string, userName: any): Promise<OpenFgaResponse> {
    const url = `${this.baseUrl}/stores/${this.storeId}/write`;

    const requestBody = {
      writes: {
        tuple_keys: [
          {
            _description: `Add ${userName} as ${accessType} on catalog_entity:${entityName}`,
            user: `${userName}`,
            relation: accessType,
            object: `catalog_entity:${entityName}`
          }
        ]
      },
      authorization_model_id: this.authorizationModelId
    };

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    const data = await response.json() as OpenFgaResponse;
    return data;
  }

  async revokePolicy(entityName: string, accessType: string, userName: any): Promise<OpenFgaResponse> {
    const url = `${this.baseUrl}/stores/${this.storeId}/write`;

    const requestBody = {
      deletes: {
        tuple_keys: [
          {
            _description: `Revoke ${userName} as ${accessType} on catalog_entity:${entityName}`,
            user: `${userName}`,
            relation: accessType,
            object: `catalog_entity:${entityName}`
          }
        ]
      },
      authorization_model_id: this.authorizationModelId
    };

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    const data = await response.json() as OpenFgaResponse;
    return data;
  }
}



plugin.ts


import {
  createPlugin,
  createRoutableExtension,
} from '@backstage/core-plugin-api';
import { Config } from '@backstage/config';
import { rootRouteRef } from './routes';
import { OpenFgaClient } from './Client';

export const openfgaPlugin = createPlugin({
  id: 'openfga',
  routes: {
    root: rootRouteRef,
  },
  register({ router, config }) {
    // Read configuration values from config
    const baseUrl = config.getString('openfga.baseUrl');
    const storeId = config.getString('openfga.storeId');
    const authorizationModelId = config.getString('openfga.authorizationModelId');
    
    const openFgaClient = new OpenFgaClient(baseUrl, storeId, authorizationModelId);

    // You can now use openFgaClient within this plugin
  },
});

export const OpenfgaPage = openfgaPlugin.provide(
  createRoutableExtension({
    name: 'OpenfgaPage',
    component: () =>
      import('./components/HeaderComponent').then(m => m.HeaderComponent),
    mountPoint: rootRouteRef,
  }),
);