import {
  Policy,
  PolicyQuery,
  PolicyDecision,
  PolicyQueryUser,
} from '@backstage/plugin-permission-common';
import { CatalogClient } from '@backstage/catalog-client';
import { Config } from '@backstage/config';
import { OpenFGAPolicyEvaluator } from '../openfgaPolicyEvaluator'; // Ensure the correct import path

export class CustomPolicy implements Policy {
  private readonly catalogClient: CatalogClient;
  private readonly openFgaPolicyEvaluator: OpenFGAPolicyEvaluator;

  constructor(config: Config) {
    this.catalogClient = new CatalogClient({ discoveryApi: config.getString('backend.baseUrl') });
    this.openFgaPolicyEvaluator = new OpenFGAPolicyEvaluator(config);
  }

  async handle(
    query: PolicyQuery,
    user?: PolicyQueryUser
  ): Promise<PolicyDecision> {
    const { permission } = query;

    // Fetch entities dynamically from Backstage catalog
    const entities = await this.catalogClient.getEntities({
      filter: { kind: 'Component' }, // Modify this filter based on requirements
    });

    if (!entities.items || entities.items.length === 0) {
      return { result: 'DENY' };
    }

    // Find entity based on permission name
    const entity = entities.items.find(e => e.metadata.name === permission.name);
    if (!entity) {
      return { result: 'DENY' };
    }

    // Ensure user identity exists
    if (!user || !user.info || !user.info.entityRef) {
      return { result: 'DENY' };
    }

    // Evaluate permission using OpenFGAPolicyEvaluator
    const isAllowed = await this.openFgaPolicyEvaluator.evaluate({
      user: user.info.entityRef,
      entity: entity.metadata.name,
      action: permission.name, // Modify this according to your OpenFGA schema
    });

    return isAllowed ? { result: 'ALLOW' } : { result: 'DENY' };
  }
}