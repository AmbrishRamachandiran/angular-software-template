policy.ts

// packages/backend/src/policy.ts

import {
  AuthorizeResult,
  PolicyDecision,
  isResourcePermission,
} from '@backstage/plugin-permission-common';
import {
  PermissionPolicy,
  PolicyQuery,
  createConditionFactory,
} from '@backstage/plugin-permission-node';
import { BackstageIdentityResponse } from '@backstage/plugin-auth-node';
import { createCatalogConditionalDecision, catalogConditions, createCatalogPermissionRule } from '@backstage/plugin-catalog-backend/alpha';
import { sendPermissionRequest } from './client';
import { Config } from '@backstage/config';
import { z } from 'zod';
import { Entity } from '@backstage/catalog-model';

const isInSystemRule = createCatalogPermissionRule({
  name: 'IS_IN_SYSTEM',
  description: 'Checks if an entity is part of the system provided',
  resourceType: 'catalog-entity',
  paramsSchema: z.object({
    systemRef: z
      .string()
      .describe('SystemRef to check the resource is part of'),
  }),
  apply: (resource: Entity, { systemRef }) => {
    if (!resource.relations) {
      return false;
    }

    return resource.relations
      .filter(relation => relation.type === 'partOf')
      .some(relation => relation.targetRef === systemRef);
  },
  toQuery: ({ systemRef }) => ({
    key: 'relations.partOf',
    values: [systemRef],
  }),
});

const isInSystem = createConditionFactory(isInSystemRule);

export class AOpenFgaCatalogPolicy implements PermissionPolicy {
  private config: Config;

  constructor(config: Config) {
    this.config = config;
  }

  async handle(
    request: PolicyQuery,
    user?: BackstageIdentityResponse,
  ): Promise<PolicyDecision> {
    if (isResourcePermission(request.permission, 'catalog-entity')) {
      // Handle the specific delete permission
      if (request.permission.name === 'catalog.entity.delete') {
        const entityName = this.extractEntityName(request.attributes?.resourceRef);

        if (!entityName) {
          return { result: AuthorizeResult.DENY };
        }

        try {
          const response = await sendPermissionRequest(
            entityName,
            'Delete',
            this.config,
          );

          if (response.allowed) {
            return { result: AuthorizeResult.ALLOW };
          } else {
            return { result: AuthorizeResult.DENY };
          }
        } catch (error) {
          console.error('Error checking permission:', error);
          return { result: AuthorizeResult.DENY };
        }
      }

      return createCatalogConditionalDecision(
        request.permission,
        catalogConditions.isEntityOwner({
          claims: user?.identity.ownershipEntityRefs ?? [],
        }),
        {
          anyOf: [
            catalogConditions.isEntityOwner({
              claims: user?.identity.ownershipEntityRefs ?? [],
            }),
            isInSystem({ systemRef: 'interviewing' }),
          ],
        },
      );
    }

    return { result: AuthorizeResult.ALLOW };
  }

  private extractEntityName(resourceRef: string | undefined): string | null {
    if (!resourceRef) {
      return null;
    }
    const match = resourceRef.match(/[^/]+$/);
    return match ? match[0] : null;
  }
}





Updated client.ts

import fetch from 'node-fetch';
import { Config } from '@backstage/config';

interface OpenFgaRequest {
  tuple_key: { user: string; relation: string; object: string };
  authorization_model_id: string;
}

interface OpenFgaResponse {
  allowed: boolean;
}

let permissionResponse: OpenFgaResponse | null = null;

export function getPermissionResponse(): OpenFgaResponse | null {
  return permissionResponse;
}

export async function sendPermissionRequest(entityName: string, action: string, config: Config): Promise<OpenFgaResponse> {
  const openFgaBaseUrl = config.getOptionalString('openfga.baseUrl') || 'http://localhost:8080';
  const openFgaStoreId = config.getOptionalString('openfga.storeId') || '01J20QE9WMGWRRD7FSKJ703JJD';

  const url = `${openFgaBaseUrl}/stores/${openFgaStoreId}/check`;

  const relation = action.toLowerCase() === 'delete' ? 'catalog_entity_delete' : 'catalog_entity_read';

  const requestBody: OpenFgaRequest = {
    tuple_key: {
      user: 'user:guest',
      relation,
      object: `catalog_entity:${entityName}`,
    },
    authorization_model_id: '01J20QHJVYWEADD27RP36HT38A',
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    throw new Error(`OpenFGA API call failed with status: ${response.status}`);
  }

  const data: OpenFgaResponse = await response.json();
  permissionResponse = data;
  return data;
}



module.ts

// packages/backend/src/module.ts
import { AOpenFgaCatalogPolicy } from './policy';
import { createBackendModule } from '@backstage/backend-plugin-api';
import { policyExtensionPoint } from '@backstage/plugin-permission-node/alpha';
import { Config } from '@backstage/config';
import { useApi } from '@backstage/core-plugin-api';

export const permissionModuleACatalogPolicy = createBackendModule({
  pluginId: 'permission',
  moduleId: 'a-name-policy',
  register(reg) {
    reg.registerInit({
      deps: { policy: policyExtensionPoint },
      async init({ policy }) {
        // Accessing the configuration from the backend environment
        const config: Config = useApi(configApiRef);

        policy.setPolicy(new AOpenFgaCatalogPolicy(config));
      },
    });
  },
});





import {
  AuthorizeResult,
  PolicyDecision,
  isResourcePermission,
} from '@backstage/plugin-permission-common';
import {
  PermissionPolicy,
  PolicyQuery,
} from '@backstage/plugin-permission-node';
import { BackstageIdentityResponse } from '@backstage/plugin-auth-node';
import { Config } from '@backstage/config';
import { sendPermissionRequest } from './client';

export class AOpenFgaCatalogPolicy implements PermissionPolicy {
  private config: Config;

  constructor(config: Config) {
    this.config = config;
  }

  async handle(
    request: PolicyQuery,
    user?: BackstageIdentityResponse,
  ): Promise<PolicyDecision> {
    // Check if the request is for catalog-entity permissions
    if (isResourcePermission(request.permission, 'catalog-entity')) {
      if (request.permission.name === 'catalog.entity.delete') {
        // Extract the entity name from the permission's parameters if available
        const entityName = request.permission.parameters?.entityName as string;

        if (!entityName) {
          // If entity name is not provided, deny the permission
          return { result: AuthorizeResult.DENY };
        }

        try {
          // Send a permission request to the OpenFGA API
          const response = await sendPermissionRequest(
            entityName,
            'Delete',
            this.config,
          );

          // Return ALLOW or DENY based on the response from the OpenFGA API
          return response.allowed
            ? { result: AuthorizeResult.ALLOW }
            : { result: AuthorizeResult.DENY };
        } catch (error) {
          console.error('Error checking permission:', error);
          return { result: AuthorizeResult.DENY };
        }
      }

      // For other catalog-entity permissions, you can add additional conditions here
      return { result: AuthorizeResult.ALLOW };
    }

    // Deny all other permissions by default
    return { result: AuthorizeResult.DENY };
  }
}
