import React, { useState, useEffect } from 'react';
import { Box, Typography, Select, MenuItem, FormControl, FormLabel, Button } from '@material-ui/core';
import { makeStyles } from '@material-ui/core/styles';
import { sendPermissionRequest, addPolicy, revokePolicy } from '../../client'; 
import Alert from '@material-ui/lab/Alert';

import { useApi, identityApiRef } from '@backstage/core-plugin-api';
import { CATALOG_FILTER_EXISTS, catalogApiRef } from '@backstage/plugin-catalog-react';

const actionOptions = ['Read', 'Delete'];
const accessTypeOptions = ['owner', 'viewer'];

const useStyles = makeStyles({
  success: {
    color: 'green',
  },
  danger: {
    color: 'red',
  },
  info: {
    color: 'blue',
  },
});

export const OpenfgaCatalogComponent = () => {
  const classes = useStyles();
  const [entities, setEntities] = useState<string[]>([]);
  const [user, setUser] = useState<string>('');
  const [selectedEntity, setSelectedEntity] = useState<string>('');
  const [selectedAction, setSelectedAction] = useState<string>(actionOptions[0]);
  const [selectedAccessType, setSelectedAccessType] = useState<string>(accessTypeOptions[0]);
  const [allowMessage, setAllowMessage] = useState<string>('');
  const [denyMessage, setDenyMessage] = useState<string>('');
  const [policyMessage, setPolicyMessage] = useState<string>('');
  const catalogApi = useApi(catalogApiRef);
  const identityApi = useApi(identityApiRef);

  const handleEntityChange = (event: any) => {
    setSelectedEntity(event.target.value);
  };

  const handleActionChange = (event: any) => {
    setSelectedAction(event.target.value);
  };

  const handleAccessTypeChange = (event: any) => {
    setSelectedAccessType(event.target.value);
  };

  const fetchEntities = async () => {
    try {
      const { items } = await catalogApi.getEntities({ 
        fields: ['metadata.name'],
        filter: {
          'kind=component': CATALOG_FILTER_EXISTS,
        },
      });
      const entityNames = items.map((entity) => entity.metadata.name);
      console.log(entityNames);
      const { ownershipEntityRefs } = await identityApi.getBackstageIdentity();
      setUser(ownershipEntityRefs);
      setEntities(entityNames);
      if (entityNames.length > 0) {
        setSelectedEntity(entityNames[0]);
      }
    } catch (error) {
      console.error('Error fetching catalog entities:', error);
    }
  };

  useEffect(() => {
    fetchEntities();
  }, []);

  const handleActivatePolicy = async () => {
    const response = await sendPermissionRequest(selectedEntity, selectedAction, user);
    if (response.allowed) {
      setAllowMessage(`${user} Has permission to ${selectedAction} the ${selectedEntity}`);
    } else {
      setDenyMessage(`${user} Don't have permission to ${selectedAction} the ${selectedEntity}`);
    }
    setTimeout(() => {
      setAllowMessage('');
      setDenyMessage('');
    }, 5000);
  };

  const handleAddPolicy = async () => {
    const response = await addPolicy(selectedEntity, selectedAccessType, user);
    if (response.ok) {
      setPolicyMessage(selectedAccessType === 'owner' ? 
        'Added permission for user to read/delete the entity' :
        'Added permission for user to read not delete the entity');
    } else {
      setPolicyMessage(response.message);
    }
    setTimeout(() => {
      setPolicyMessage('');
    }, 5000);
  };

  const handleRevokePolicy = async () => {
    const response = await revokePolicy(selectedEntity, selectedAccessType, user);
    if (response.ok) {
      setPolicyMessage(selectedAccessType === 'owner' ? 
        'Revoked permission for user to read/delete the entity' :
        'Revoked permission for user to read not delete the entity');
    } else {
      setPolicyMessage(response.message);
    }
    setTimeout(() => {
      setPolicyMessage('');
    }, 5000);
  };

  return (
    <Box sx={{ border: 1, borderRadius: 0, p: 2, bgcolor: 'cyan', display: 'flex', flexDirection: 'row', justifyContent: 'space-between' }}>
      <Box sx={{ width: '45%' }}>
        <Typography className={classes.info} variant="body2" gutterBottom>
          {user}
        </Typography>
        <Typography variant="h6" gutterBottom>
          START EXISTING POLICY
        </Typography>
        <Box sx={{ display: 'flex', flexDirection: 'column' }}>
          <FormControl>
            <FormLabel>Select Entity</FormLabel>
            <Select
              value={selectedEntity}
              onChange={handleEntityChange}
              label="Select Entity"
            >
              {entities.map((entityName: string) => (
                <MenuItem key={entityName} value={entityName}>
                  {entityName}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          <FormControl>
            <FormLabel>Select Action</FormLabel>
            <Select
              value={selectedAction}
              onChange={handleActionChange}
              label="Select Action"
            >
              {actionOptions.map((option) => (
                <MenuItem key={option} value={option}>
                  {option}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Box>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
          <Button
            className={classes.success}
            variant="contained"
            onClick={handleActivatePolicy}
          >
            Start Policy
          </Button>
        </Box>
        {allowMessage && (
          <Alert severity="success">{allowMessage}</Alert>
        )}
        {denyMessage && (
          <Alert severity="success">{denyMessage}</Alert>
        )}
      </Box>

      <Box sx={{ width: '45%' }}>
        <Typography className={classes.info} variant="body2" gutterBottom>
          {user}
        </Typography>
        <Typography variant="h6" gutterBottom>
          MODIFY/ADD POLICY
        </Typography>
        <Box sx={{ display: 'flex', flexDirection: 'column' }}>
          <FormControl>
            <FormLabel>Select Entity</FormLabel>
            <Select
              value={selectedEntity}
              onChange={handleEntityChange}
              label="Select Entity"
            >
              {entities.map((entityName: string) => (
                <MenuItem key={entityName} value={entityName}>
                  {entityName}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          <FormControl>
            <FormLabel>Select Access Type</FormLabel>
            <Select
              value={selectedAccessType}
              onChange={handleAccessTypeChange}
              label="Select Access Type"
            >
              {accessTypeOptions.map((option) => (
                <MenuItem key={option} value={option}>
                  {option}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Box>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
          <Button
            className={classes.success}
            variant="contained"
            onClick={handleAddPolicy}
          >
            Add Policy
          </Button>
          <Button
            className={classes.danger}
            variant="contained"
            onClick={handleRevokePolicy}
          >
            Revoke Policy
          </Button>
        </Box>
        {policyMessage && (
          <Alert severity={policyMessage.includes('Added') ? 'success' : 'error'}>{policyMessage}</Alert>
        )}
      </Box>
    </Box>
  );
};







client.ts

import fetch from 'node-fetch';

interface OpenFgaRequest {
  tuple_key: { user: string; relation: string; object: string };
  authorization_model_id: string;
}

interface OpenFgaResponse {
  allowed: boolean;
  ok?: boolean;
  message?: string;
}

let permissionResponse: OpenFgaResponse | null = null;

export function getPermissionResponse(): OpenFgaResponse | null {
  return permissionResponse;
}

const openFgaBaseUrl = 'http://localhost:8080';
const openFgaStoreId = '01J20QE9WMGWRRD7FSKJ703JJD';
const authorizationModelId = '01J20QHJVYWEADD27RP36HT38A';

export async function sendPermissionRequest(entityName: string, action: string, userName: any): Promise<OpenFgaResponse> {
  const url = `${openFgaBaseUrl}/stores/${openFgaStoreId}/check`;

  const relation = action.toLowerCase() === 'delete' ? 'catalog_entity_delete' : 'catalog_entity_read';

  const requestBody: OpenFgaRequest = {
    tuple_key: {
      user: `${userName}`,
      relation,
      object: `catalog_entity:${entityName}`,
    },
    authorization_model_id: authorizationModelId,
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    throw new Error(`OpenFGA API call failed with status: ${response.status}`);
  }

  const data: OpenFgaResponse = await response.json();
  permissionResponse = data;
  return data;
}

export async function addPolicy(entityName: string, accessType: string, userName: any): Promise<OpenFgaResponse> {
  const url = `${openFgaBaseUrl}/stores/${openFgaStoreId}/write`;

  const requestBody = {
    writes: {
      tuple_keys: [
        {
          _description: `Add ${userName} as ${accessType} on catalog_entity:${entityName}`,
          user: `user:${userName}`,
          relation: accessType,
          object: `catalog_entity:${entityName}`
        }
      ]
    },
    authorization_model_id: authorizationModelId
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  const data: OpenFgaResponse = await response.json();
  return data;
}

export async function revokePolicy(entityName: string, accessType: string, userName: any): Promise<OpenFgaResponse> {
  const url = `${openFgaBaseUrl}/stores/${openFgaStoreId}/write`;

  const requestBody = {
    deletes: {
      tuple_keys: [
        {
          _description: `Revoke ${userName} as ${accessType} on catalog_entity:${entityName}`,
          user: `user:${userName}`,
          relation: accessType,
          object: `catalog_entity:${entityName}`
        }
      ]
    },
    authorization_model_id: authorizationModelId
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  const data: OpenFgaResponse = await response.json();
  return data;
}
