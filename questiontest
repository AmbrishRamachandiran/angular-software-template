import {
  AuthorizeResult,
  PolicyDecision,
  isResourcePermission,
} from '@backstage/plugin-permission-common';
import { CatalogClient, CatalogApi } from '@backstage/catalog-client';
import {
  PermissionPolicy,
  PolicyQuery,
  PolicyQueryUser,
} from '@backstage/plugin-permission-node';
import { BackstageIdentityResponse } from '@backstage/plugin-auth-node';
import { ConfigApi, DiscoveryApi, IdentityApi } from '@backstage/core-plugin-api';
import { openFgaPolicyEvaluator } from './openFgaPolicyEvaluator';

export class OpenFgaCatalogPolicy implements PermissionPolicy {
  private openFgaClient: openFgaPolicyEvaluator;
  private catalogApi: CatalogApi;
  private identityApi: IdentityApi;

  constructor(configApi: ConfigApi, discoveryApi: DiscoveryApi, identityApi: IdentityApi, catalogApi?: CatalogApi) {
    this.openFgaClient = openFgaPolicyEvaluator.fromConfig(
      configApi,
      discoveryApi,
    );
    this.identityApi = identityApi;
    // Initialize CatalogApi if not provided
    this.catalogApi = catalogApi || new CatalogClient({ discoveryApi });
    console.log('CatalogApi initialized:', !!this.catalogApi);
  }

  async handle(
    request: PolicyQuery,
    user?: PolicyQueryUser,
  ): Promise<PolicyDecision> {
    const identityUser = user as BackstageIdentityResponse;

    // Check if the request is for catalog-entity permissions
    if (isResourcePermission(request.permission, 'catalog-entity')) {
      if (request.permission.name === 'catalog.entity.delete') {
        // Fetch the entity name dynamically
        const entityName = await this.getEntityName(request, identityUser);
        console.log(entityName, "entityName");
        const userName = identityUser?.identity.ownershipEntityRefs;

        if (!entityName) {
          // If entity name is not provided, deny the permission
          return { result: AuthorizeResult.DENY };
        }

        try {
          // Send a permission request to the OpenFGA API using the client instance
          const response = await this.openFgaClient.sendPermissionRequest(
            entityName,
            'Delete',
            userName,
          );

          // Return ALLOW or DENY based on the response from the OpenFGA API
          return response.allowed
            ? { result: AuthorizeResult.ALLOW }
            : { result: AuthorizeResult.DENY };
        } catch (error) {
          console.error('Error checking permission:', error);
          return { result: AuthorizeResult.DENY };
        }
      }

      // For other catalog-entity permissions, you can add additional conditions here
      return { result: AuthorizeResult.ALLOW };
    }

    // Deny all other permissions by default
    return { result: AuthorizeResult.DENY };
  }

  // Method to fetch the entity name dynamically
  private async getEntityName(request: PolicyQuery, identityUser?: BackstageIdentityResponse): Promise<string | undefined> {
    // Example logic to fetch the entity reference from the request or user information
    let entityRef = this.extractEntityRefFromRequest(request, identityUser);
    console.log(`Extracted entityRef: ${entityRef}`);
    if (!entityRef) {
      console.error('Entity reference is not available.');
      return undefined;
    }

    // Ensure the entityRef is in the correct format
    entityRef = this.formatEntityRef(entityRef);
    console.log(`Formatted entityRef: ${entityRef}`);

    try {
      // Get the Backstage identity token from identityUser
      const token = identityUser?.token;
      if (!token) {
        console.error('Token is not available.');
        return undefined;
      }

      console.log(`Fetching entity with ref: ${entityRef} and token: ${token}`);
      
      // Attempt to fetch the entity using getEntityByRef
      const entity = await this.catalogApi.getEntityByRef(entityRef, { token });
      console.log(`Fetched entity: ${entity}`);

      // If entity is not found, try to list all entities and find the matching one
      if (!entity) {
        console.error('Entity is not found using getEntityByRef.');

        const entitiesResponse = await this.catalogApi.getEntities({
          filter: { 'metadata.name': this.extractEntityNameFromRef(entityRef) },
        }, { token });

        console.log(`Entities response: ${JSON.stringify(entitiesResponse)}`);
        if (entitiesResponse.items.length > 0) {
          const foundEntity = entitiesResponse.items.find(item => item.metadata.name === this.extractEntityNameFromRef(entityRef));
          console.log(`Found entity: ${foundEntity}`);
          return foundEntity?.metadata.name;
        } else {
          console.error('Entity is not found in the catalog.');
          return undefined;
        }
      }

      if (!entity.metadata) {
        console.error('Metadata is not available on the entity.');
        return undefined;
      }

      if (!entity.metadata.name) {
        console.error('Entity name is not available in metadata.');
        return undefined;
      }

      return entity.metadata.name;
    } catch (error) {
      console.error('Error fetching entity:', error);
      return undefined;
    }
  }

  // Helper method to extract the entity reference from the request or user information
  private extractEntityRefFromRequest(request: PolicyQuery, identityUser?: BackstageIdentityResponse): string | undefined {
    // Implement the logic to extract the entity reference from the request or user information
    if (!identityUser?.identity.ownershipEntityRefs || identityUser.identity.ownershipEntityRefs.length === 0) {
      console.error('Ownership entity references are not available.');
      return undefined;
    }
    return identityUser.identity.ownershipEntityRefs[0]; // Example: using the first ownership entity reference
  }

  // Helper method to format the entity reference
  private formatEntityRef(entityRef: string): string {
    if (!entityRef.includes(':')) {
      return `user:${entityRef}`;
    }
    return entityRef;
  }

  // Helper method to extract the entity name from the entity reference
  private extractEntityNameFromRef(entityRef: string): string {
    return entityRef.split(':')[1];
  }
}
